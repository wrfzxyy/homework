# 第一周正式课–课后作业（3）
##2、写出下面代码输出的结果
- undefined
- ‘language’

##3、写出下面代码输出的结果
- ‘window’

##5、写出下面代码输出的结果
- ‘12’

##7、以下代码的功能是要实现为5个input按钮循环绑定click点击事件，绑定完成后点击1、2、3、4、5五个按钮分别会alert输出0、1、2、3、4五个字符。
- 当前代码不能实现，因为没有产生闭包，最终输出的i为循环结束后的5，点击任意一个按钮都会输出5
- 解决方法(1)
  - 基于LET方法产生块级作用域，循环中会产生父作用域控制循环，每轮循环都会产生一个子作用域，保存下每轮循环的i的值，再去绑定点击事件后就会输出每轮循环的i的值，0.1.2.3.4
```
var btnBox=document.getElementById('btnBox'),
        inputs=btnBox.getElementsByTagName('input');
    var l=inputs.length;
    for(let i=0;i<l;i++){
        inputs[i].onclick=function(){
            alert(i);
        }
    }
``` 
- 解决方法(2)
   - 基于自定义属性的方式，通过循环给每一轮的按钮绑定自定义属性=i的方式解决，就可以输出0.1.2.3.4，而且此方法会优于其他方案，无论let和闭包，机制类似，都是要创建私有上下文，如果过多使用这两种方案，会影响加载速度
```
var btnBox=document.getElementById('btnBox'),
        inputs=btnBox.getElementsByTagName('input');
    var l=inputs.length;
    for(var i=0;i<l;i++){
        inputs[i].my=i;
        inputs[i].onclick=function(){
            alert(this.my);
        }
    }
```

##8、你理解的闭包作用是什么，优缺点？
- 闭包：函数中形成的私有上下文中创建的堆被外界引用，此时私有上下文不销毁，以及私有上下文中的值和外界并无必然联系，起到保护作用
- 优点：不会造成全局变量污染，能有效的保护私有上下文中的值
- 缺点：过多使用闭包会造成很多不销毁的私有栈，导致栈内存溢出，使运行速度变慢

##9、简述let和var的区别
-var和let的区别
 1、let不存在变量提升，var存在变量提升
 2、let不允许重复声明同一个变量，var可以
 3、let声明的值和go无关联，var声明的值和go有关联
 4、let可以解决浏览器的暂时性死区
 5、在除对象和函数的大块好一位，在其它的大括号中会产生块级作用域，是括号内的内容形成一个私有的上下文

##10、改造下面代码，使之输出0-9
基于let
```
for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
```

##11、下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出 20 10？
- 输出为函数b本身，和10
>立即执行具名函数表达式
>1.作为函数名的变量只能从函数体内部访问，在函数外部访问不到 
>2.指向函数名的变量不能再绑定为其它值，即该变量指向是不可更改的 
所以在具名函数中的b的指向不能重新指向20

改造为
```
var b = 10;
(function b() {
    var b = 20;
    console.log(b);
})();
console.log(b);
```